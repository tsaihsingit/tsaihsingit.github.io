<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>教室留言板</title>
  
  <!-- 引入 React 和 ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  
  <!-- 引入 Babel 用於解析 JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- 引入 Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- 定義一些自定義樣式 -->
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    /* 隱藏捲軸但保留功能 */
    textarea::-webkit-scrollbar { display: none; }
    textarea { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- 圖示組件 (SVG) ---
    const Icon = ({ children, className, ...props }) => (
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        width="24" height="24" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round" 
        className={className} 
        {...props}
      >
        {children}
      </svg>
    );

    const Icons = {
      Sun: (props) => <Icon {...props}><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></Icon>,
      Moon: (props) => <Icon {...props}><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></Icon>,
      Copy: (props) => <Icon {...props}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
      Check: (props) => <Icon {...props}><polyline points="20 6 9 17 4 12"/></Icon>,
      Trash2: (props) => <Icon {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></Icon>,
      Cookie: (props) => <Icon {...props}><path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5 4 4 0 0 1-5-5"/><path d="M8.5 8.5v.01"/><path d="M16 15.5v.01"/><path d="M12 12v.01"/><path d="M11 17v.01"/><path d="M7 14v.01"/></Icon>,
      Database: (props) => <Icon {...props}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></Icon>,
      Loader2: (props) => <Icon {...props} className={`${props.className || ''} animate-spin`}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></Icon>,
      Save: (props) => <Icon {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>
    };

    // --- Storage Helper Functions (Hybrid + CHIPS) ---
    
    const setStorage = (key, value, days) => {
      // 1. Cookie with CHIPS (Partitioned) - 針對 Chrome iframe 的關鍵修復
      try {
        const expires = new Date(Date.now() + days * 864e5).toUTCString();
        // 加入 "Partitioned" 屬性，這是現代瀏覽器允許 iframe 存取 Cookie 的關鍵
        document.cookie = key + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/; SameSite=None; Secure; Partitioned';
      } catch (e) { console.warn('Cookie write failed', e); }

      // 2. LocalStorage (備用)
      try {
        localStorage.setItem(key, value);
      } catch (e) { console.warn('LocalStorage write failed', e); }
    };

    const getStorage = (key) => {
      let value = null;

      // 1. 優先 LocalStorage
      try {
        value = localStorage.getItem(key);
      } catch (e) { console.warn('LocalStorage read failed', e); }

      if (value) return value;

      // 2. Cookie
      try {
        value = document.cookie.split('; ').reduce((r, v) => {
          const parts = v.split('=');
          return parts[0].trim() === key ? decodeURIComponent(parts[1]) : r;
        }, '');
      } catch (e) { console.warn('Cookie read failed', e); }

      return value;
    };

    // --- Main App Component ---
    const App = () => {
      const [text, setText] = useState('');
      const [darkMode, setDarkMode] = useState(true);
      const [status, setStatus] = useState('loading');
      const [copied, setCopied] = useState(false);
      const [storageType, setStorageType] = useState('Checking...');
      
      const textareaRef = useRef(null);
      const isFirstLoad = useRef(true);

      // 1. 初始讀取
      useEffect(() => {
        console.log('--- 系統啟動資料讀取 ---');
        
        let savedData = '';
        let savedTheme = '';
        
        savedData = getStorage('typing_content');
        savedTheme = getStorage('typing_theme');
        
        // Debug 來源顯示 (使用 try-catch 防止安全錯誤)
        let source = 'None';
        try {
            // 先檢查有沒有值，不要直接讀取以免報錯
            // 這裡僅做簡單判斷
            if (savedData) {
               // 再次嘗試判斷來源，但不強求
               if (document.cookie.indexOf('typing_content') !== -1) source += ' Cookie(CHIPS)';
               // LocalStorage 檢查比較容易報錯，放後面
               try { if (localStorage.getItem('typing_content')) source += ' LS'; } catch(e){}
            }
        } catch(e) { console.log('Debug check skipped'); }
        
        if (source === 'None' && savedData) source = 'Unknown(Cached)';
        
        console.log(`讀取結果: ${savedData ? '成功' : '無資料'} (來源推測: ${source})`);
        setStorageType(source);

        if (savedData) {
          setText(savedData);
        }
        
        if (savedTheme) {
          setDarkMode(savedTheme === 'true');
        }

        setStatus('saved');
        isFirstLoad.current = false;
        
        if (textareaRef.current) textareaRef.current.focus();
      }, []);

      // 2. 儲存邏輯
      useEffect(() => {
        if (isFirstLoad.current) return;

        setStatus('saving');

        const timer = setTimeout(() => {
          try {
            setStorage('typing_content', text, 180);
            setStorage('typing_theme', darkMode.toString(), 180);

            // 簡易驗證
            let verifyMsg = 'Sent';
            try {
               const hasCookie = document.cookie.indexOf('typing_content') !== -1;
               if (hasCookie) verifyMsg = 'Cookie OK';
            } catch(e) {}
            
            console.log(`✅ [Storage] 寫入完畢 (${verifyMsg}) | 長度: ${text.length}`);
            
            setStatus('saved');
          } catch (e) {
            console.error('❌ [Storage] 寫入失敗:', e);
            setStatus('error');
          }
        }, 500);

        return () => clearTimeout(timer);
      }, [text, darkMode]);

      // --- 字體大小計算邏輯 ---
      const calculateStyle = () => {
        const len = text.length || 1;
        const calculated = 90 / len;
        const size = Math.min(Math.max(calculated, 2.5), 10);
        const isMinSize = size <= 2.5;

        return {
          fontSize: `${size}vw`,
          whiteSpace: isMinSize ? 'pre-wrap' : 'nowrap',
          paddingTop: isMinSize ? '4rem' : '40vh', 
        };
      };

      const currentStyle = calculateStyle();

      const handleCopy = () => {
        if (!text) return;
        navigator.clipboard.writeText(text)
          .then(() => {
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          })
          .catch(err => {
            console.error('Copy failed', err);
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand("copy");
            document.body.removeChild(textArea);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          });
      };

      const handleClear = () => {
        if (window.confirm('確定清空？(這也會清除存檔)')) {
          setText('');
          if (textareaRef.current) textareaRef.current.focus();
        }
      };

      return (
        <div 
          className={`h-screen w-full transition-colors duration-500 ease-in-out flex flex-col overflow-hidden ${
            darkMode ? 'bg-slate-900 text-slate-100' : 'bg-slate-50 text-slate-900'
          }`}
        >
          {/* 工具列 */}
          <div className="absolute top-0 left-0 w-full p-4 flex justify-between items-center z-10 opacity-30 hover:opacity-100 transition-opacity duration-300">
            <div className="flex items-center gap-3 font-mono text-xs">
              <span className="opacity-70">{text.length} chars</span>
              <span className="opacity-40">|</span>
              <span className="opacity-70">{currentStyle.fontSize}</span>
            </div>
            
            <div className="flex gap-2">
              <button onClick={() => setDarkMode(!darkMode)} className="p-2 rounded-full hover:bg-white/10 transition-colors">
                {darkMode ? <Icons.Sun size={20} /> : <Icons.Moon size={20} />}
              </button>
              <button onClick={handleCopy} className="p-2 rounded-full hover:bg-white/10 transition-colors" disabled={!text}>
                {copied ? <Icons.Check size={20} className="text-green-500" /> : <Icons.Copy size={20} />}
              </button>
              <button onClick={handleClear} className="p-2 rounded-full hover:bg-red-500/20 hover:text-red-500 transition-colors" disabled={!text}>
                <Icons.Trash2 size={20} />
              </button>
            </div>
          </div>

          {/* 輸入區 */}
          <main className="flex-1 w-full h-full flex flex-col justify-center items-center relative overflow-hidden">
            <textarea
              ref={textareaRef}
              value={text}
              onChange={(e) => setText(e.target.value)}
              placeholder="TYPE HERE"
              className="w-full h-full bg-transparent border-none outline-none resize-none text-center font-bold leading-tight transition-all duration-300 ease-out placeholder:opacity-10 p-4"
              style={{
                fontSize: currentStyle.fontSize,
                whiteSpace: currentStyle.whiteSpace,
                paddingTop: currentStyle.paddingTop, 
              }}
              spellCheck="false"
            />
          </main>

          {/* 底部狀態 */}
          <div className="absolute bottom-3 left-0 w-full px-6 flex justify-between items-end pointer-events-none opacity-50 text-[10px] font-mono">
            <div className="flex items-center gap-2">
               {status === 'saved' && (
                 <>
                   <Icons.Database size={12} className="text-blue-400" />
                   <span>Saved (Hybrid + CHIPS)</span>
                 </>
               )}
               {status === 'saving' && (
                 <>
                   <Icons.Loader2 size={12} className="animate-spin" />
                   <span>Saving...</span>
                 </>
               )}
               {status === 'error' && (
                 <>
                   <Icons.Save size={12} className="text-red-500" />
                   <span className="text-red-500">Storage Error</span>
                 </>
               )}
            </div>
            <div>
              Source: {storageType}
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>